
TestAddressNotAligned.elf:     file format elf32-tradlittlemips

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000e94  00000000  00000000  00010000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
SYMBOL TABLE:
00000000 l    d  .text	00000000 .text
00000000 l       .text	00000000 _RESET_Vector
00000050 l       .text	00000000 _RESET_Handler
00000010 l       .text	00000000 _IP0_Vector
00000070 l       .text	00000000 _IP0_Handler
00000020 l       .text	00000000 _IP2_Vector
00000090 l       .text	00000000 _IP2_Handler
00000030 l       .text	00000000 _IP3_Vector
000000b0 l       .text	00000000 _IP3_Handler
00000040 l       .text	00000000 _IP4_Vector
000000d0 l       .text	00000000 _IP4_Handler
000000f0 l       .text	00000000 _save_regs
00000138 l       .text	00000000 _restore_regs
000001cc g     F .text	00000030 in32
00000244  w    F .text	00000024 IP3_Handler
00000d14 g     F .text	00000094 memcpy
000003e0 g     F .text	00000094 _mtc0
000001fc  w    F .text	00000024 IP0_Handler
00000790 g     F .text	00000148 ChannelEnable
0000028c g     F .text	00000060 cpu_enable_interrupt
00000268  w    F .text	00000024 IP4_Handler
000002ec g     F .text	00000068 cpu_disable_interrupt
000008d8 g     F .text	00000148 InterruptAck
00000a20  w    F .text	00000028 outbyte
00000188 g     O .text	00000000 _di
00000190 g     F .text	0000003c out32
00000da8 g     F .text	0000007c memset
00000ad4 g     F .text	00000240 main
00000474 g     F .text	0000031c DMA_init
00000e24 g     F .text	00000070 _premain
00000a48  w    F .text	00000024 inbyte
00000a6c g     F .text	00000068 IP2_Handler
00000180 g     O .text	00000000 _ei
00000354 g     F .text	0000008c _mfc0



Disassembly of section .text:

00000000 <_RESET_Vector>:
   0:	10000013 	b	50 <_RESET_Handler>
   4:	00000000 	nop
	...

00000010 <_IP0_Vector>:
  10:	10000017 	b	70 <_IP0_Handler>
  14:	00000000 	nop
	...

00000020 <_IP2_Vector>:
  20:	1000001b 	b	90 <_IP2_Handler>
  24:	00000000 	nop
	...

00000030 <_IP3_Vector>:
  30:	1000001f 	b	b0 <_IP3_Handler>
  34:	00000000 	nop
	...

00000040 <_IP4_Vector>:
  40:	10000023 	b	d0 <_IP4_Handler>
  44:	00000000 	nop
	...

00000050 <_RESET_Handler>:
  50:	3c1d0001 	lui	sp,0x1
  54:	27bd8000 	addiu	sp,sp,-32768
  58:	3c1e0001 	lui	s8,0x1
  5c:	27de8000 	addiu	s8,s8,-32768
  60:	3c1c0000 	lui	gp,0x0
  64:	279c4000 	addiu	gp,gp,16384
  68:	41606020 	ei
  6c:	08000389 	j	e24 <_premain>

00000070 <_IP0_Handler>:
  70:	27bdffb8 	addiu	sp,sp,-72
  74:	afbf0000 	sw	ra,0(sp)
  78:	0c00003c 	jal	f0 <_save_regs>
  7c:	0c00007f 	jal	1fc <IP0_Handler>
  80:	0c00004e 	jal	138 <_restore_regs>
  84:	8fbf0000 	lw	ra,0(sp)
  88:	27bd0048 	addiu	sp,sp,72
  8c:	42000018 	eret

00000090 <_IP2_Handler>:
  90:	27bdffb8 	addiu	sp,sp,-72
  94:	afbf0000 	sw	ra,0(sp)
  98:	0c00003c 	jal	f0 <_save_regs>
  9c:	0c00029b 	jal	a6c <IP2_Handler>
  a0:	0c00004e 	jal	138 <_restore_regs>
  a4:	8fbf0000 	lw	ra,0(sp)
  a8:	27bd0048 	addiu	sp,sp,72
  ac:	42000018 	eret

000000b0 <_IP3_Handler>:
  b0:	27bdffb8 	addiu	sp,sp,-72
  b4:	afbf0000 	sw	ra,0(sp)
  b8:	0c00003c 	jal	f0 <_save_regs>
  bc:	0c000091 	jal	244 <IP3_Handler>
  c0:	0c00004e 	jal	138 <_restore_regs>
  c4:	8fbf0000 	lw	ra,0(sp)
  c8:	27bd0048 	addiu	sp,sp,72
  cc:	42000018 	eret

000000d0 <_IP4_Handler>:
  d0:	27bdffb8 	addiu	sp,sp,-72
  d4:	afbf0000 	sw	ra,0(sp)
  d8:	0c00003c 	jal	f0 <_save_regs>
  dc:	0c00009a 	jal	268 <IP4_Handler>
  e0:	0c00004e 	jal	138 <_restore_regs>
  e4:	8fbf0000 	lw	ra,0(sp)
  e8:	27bd0048 	addiu	sp,sp,72
  ec:	42000018 	eret

000000f0 <_save_regs>:
  f0:	afa10004 	sw	at,4(sp)
  f4:	afa20008 	sw	v0,8(sp)
  f8:	afa3000c 	sw	v1,12(sp)
  fc:	afa40010 	sw	a0,16(sp)
 100:	afa50014 	sw	a1,20(sp)
 104:	afa60018 	sw	a2,24(sp)
 108:	afa7001c 	sw	a3,28(sp)
 10c:	afa80020 	sw	t0,32(sp)
 110:	afa90024 	sw	t1,36(sp)
 114:	afaa0028 	sw	t2,40(sp)
 118:	afab002c 	sw	t3,44(sp)
 11c:	afac0030 	sw	t4,48(sp)
 120:	afad0034 	sw	t5,52(sp)
 124:	afae0038 	sw	t6,56(sp)
 128:	afaf003c 	sw	t7,60(sp)
 12c:	afb80040 	sw	t8,64(sp)
 130:	afb90044 	sw	t9,68(sp)
 134:	03e00008 	jr	ra

00000138 <_restore_regs>:
 138:	8fa10004 	lw	at,4(sp)
 13c:	8fa20008 	lw	v0,8(sp)
 140:	8fa3000c 	lw	v1,12(sp)
 144:	8fa40010 	lw	a0,16(sp)
 148:	8fa50014 	lw	a1,20(sp)
 14c:	8fa60018 	lw	a2,24(sp)
 150:	8fa7001c 	lw	a3,28(sp)
 154:	8fa80020 	lw	t0,32(sp)
 158:	8fa90024 	lw	t1,36(sp)
 15c:	8faa0028 	lw	t2,40(sp)
 160:	8fab002c 	lw	t3,44(sp)
 164:	8fac0030 	lw	t4,48(sp)
 168:	8fad0034 	lw	t5,52(sp)
 16c:	8fae0038 	lw	t6,56(sp)
 170:	8faf003c 	lw	t7,60(sp)
 174:	8fb80040 	lw	t8,64(sp)
 178:	8fb90044 	lw	t9,68(sp)
 17c:	03e00008 	jr	ra

00000180 <_ei>:
 180:	41626020 03e00008                        `bA....

00000188 <_di>:
 188:	41626000 03e00008                       .`bA....

00000190 <out32>:
#include <cpu.h>

void out32(uint32_t addr, uint32_t data)
{
 190:	27bdfff8 	addiu	sp,sp,-8
 194:	afbe0004 	sw	s8,4(sp)
 198:	03a0f025 	move	s8,sp
 19c:	afc40008 	sw	a0,8(s8)
 1a0:	afc5000c 	sw	a1,12(s8)
	*((volatile uint32_t*) addr) = data;
 1a4:	8fc20008 	lw	v0,8(s8)
 1a8:	8fc3000c 	lw	v1,12(s8)
 1ac:	00000000 	nop
 1b0:	ac430000 	sw	v1,0(v0)
}
 1b4:	00000000 	nop
 1b8:	03c0e825 	move	sp,s8
 1bc:	8fbe0004 	lw	s8,4(sp)
 1c0:	27bd0008 	addiu	sp,sp,8
 1c4:	03e00008 	jr	ra
 1c8:	00000000 	nop

000001cc <in32>:

uint32_t in32(uint32_t addr)
{
 1cc:	27bdfff8 	addiu	sp,sp,-8
 1d0:	afbe0004 	sw	s8,4(sp)
 1d4:	03a0f025 	move	s8,sp
 1d8:	afc40008 	sw	a0,8(s8)
	return *((volatile uint32_t*) addr);
 1dc:	8fc20008 	lw	v0,8(s8)
 1e0:	00000000 	nop
 1e4:	8c420000 	lw	v0,0(v0)
}
 1e8:	03c0e825 	move	sp,s8
 1ec:	8fbe0004 	lw	s8,4(sp)
 1f0:	27bd0008 	addiu	sp,sp,8
 1f4:	03e00008 	jr	ra
 1f8:	00000000 	nop

000001fc <IP0_Handler>:

void __attribute__ ((weak)) IP0_Handler()
{
 1fc:	27bdfff8 	addiu	sp,sp,-8
 200:	afbe0004 	sw	s8,4(sp)
 204:	03a0f025 	move	s8,sp
	return;
 208:	00000000 	nop
}
 20c:	03c0e825 	move	sp,s8
 210:	8fbe0004 	lw	s8,4(sp)
 214:	27bd0008 	addiu	sp,sp,8
 218:	03e00008 	jr	ra
 21c:	00000000 	nop

void __attribute__ ((weak)) IP2_Handler()
{
 220:	27bdfff8 	addiu	sp,sp,-8
 224:	afbe0004 	sw	s8,4(sp)
 228:	03a0f025 	move	s8,sp
	return;
 22c:	00000000 	nop
}
 230:	03c0e825 	move	sp,s8
 234:	8fbe0004 	lw	s8,4(sp)
 238:	27bd0008 	addiu	sp,sp,8
 23c:	03e00008 	jr	ra
 240:	00000000 	nop

00000244 <IP3_Handler>:

void __attribute__ ((weak)) IP3_Handler()
{
 244:	27bdfff8 	addiu	sp,sp,-8
 248:	afbe0004 	sw	s8,4(sp)
 24c:	03a0f025 	move	s8,sp
	return;
 250:	00000000 	nop
}
 254:	03c0e825 	move	sp,s8
 258:	8fbe0004 	lw	s8,4(sp)
 25c:	27bd0008 	addiu	sp,sp,8
 260:	03e00008 	jr	ra
 264:	00000000 	nop

00000268 <IP4_Handler>:

void __attribute__ ((weak)) IP4_Handler()
{
 268:	27bdfff8 	addiu	sp,sp,-8
 26c:	afbe0004 	sw	s8,4(sp)
 270:	03a0f025 	move	s8,sp
	return;
 274:	00000000 	nop
}
 278:	03c0e825 	move	sp,s8
 27c:	8fbe0004 	lw	s8,4(sp)
 280:	27bd0008 	addiu	sp,sp,8
 284:	03e00008 	jr	ra
 288:	00000000 	nop

0000028c <cpu_enable_interrupt>:

void cpu_enable_interrupt(uint32_t mask)
{
 28c:	27bdffe0 	addiu	sp,sp,-32
 290:	afbf001c 	sw	ra,28(sp)
 294:	afbe0018 	sw	s8,24(sp)
 298:	03a0f025 	move	s8,sp
 29c:	afc40020 	sw	a0,32(s8)
	uint32_t val = _mfc0(CP0_STATUS);
 2a0:	2404000c 	li	a0,12
 2a4:	0c0000d5 	jal	354 <_mfc0>
 2a8:	00000000 	nop
 2ac:	afc20010 	sw	v0,16(s8)
	_mtc0(CP0_STATUS, val | mask);
 2b0:	8fc30010 	lw	v1,16(s8)
 2b4:	8fc20020 	lw	v0,32(s8)
 2b8:	00000000 	nop
 2bc:	00621025 	or	v0,v1,v0
 2c0:	00402825 	move	a1,v0
 2c4:	2404000c 	li	a0,12
 2c8:	0c0000f8 	jal	3e0 <_mtc0>
 2cc:	00000000 	nop
}
 2d0:	00000000 	nop
 2d4:	03c0e825 	move	sp,s8
 2d8:	8fbf001c 	lw	ra,28(sp)
 2dc:	8fbe0018 	lw	s8,24(sp)
 2e0:	27bd0020 	addiu	sp,sp,32
 2e4:	03e00008 	jr	ra
 2e8:	00000000 	nop

000002ec <cpu_disable_interrupt>:

void cpu_disable_interrupt(uint32_t mask)
{
 2ec:	27bdffe0 	addiu	sp,sp,-32
 2f0:	afbf001c 	sw	ra,28(sp)
 2f4:	afbe0018 	sw	s8,24(sp)
 2f8:	03a0f025 	move	s8,sp
 2fc:	afc40020 	sw	a0,32(s8)
	uint32_t val = _mfc0(CP0_STATUS);
 300:	2404000c 	li	a0,12
 304:	0c0000d5 	jal	354 <_mfc0>
 308:	00000000 	nop
 30c:	afc20010 	sw	v0,16(s8)
	_mtc0(CP0_STATUS, val & ~mask);
 310:	8fc20020 	lw	v0,32(s8)
 314:	00000000 	nop
 318:	00021827 	nor	v1,zero,v0
 31c:	8fc20010 	lw	v0,16(s8)
 320:	00000000 	nop
 324:	00621024 	and	v0,v1,v0
 328:	00402825 	move	a1,v0
 32c:	2404000c 	li	a0,12
 330:	0c0000f8 	jal	3e0 <_mtc0>
 334:	00000000 	nop
}
 338:	00000000 	nop
 33c:	03c0e825 	move	sp,s8
 340:	8fbf001c 	lw	ra,28(sp)
 344:	8fbe0018 	lw	s8,24(sp)
 348:	27bd0020 	addiu	sp,sp,32
 34c:	03e00008 	jr	ra
 350:	00000000 	nop

00000354 <_mfc0>:

unsigned _mfc0(CP0_REG_t reg)
{
 354:	27bdfff0 	addiu	sp,sp,-16
 358:	afbe000c 	sw	s8,12(sp)
 35c:	03a0f025 	move	s8,sp
 360:	afc40010 	sw	a0,16(s8)
	uint32_t val = 0;
 364:	afc00000 	sw	zero,0(s8)

	switch(reg)
 368:	8fc20010 	lw	v0,16(s8)
 36c:	2403000d 	li	v1,13
 370:	1043000c 	beq	v0,v1,3a4 <_mfc0+0x50>
 374:	00000000 	nop
 378:	2403000e 	li	v1,14
 37c:	1043000e 	beq	v0,v1,3b8 <_mfc0+0x64>
 380:	00000000 	nop
 384:	2403000c 	li	v1,12
 388:	1443000f 	bne	v0,v1,3c8 <_mfc0+0x74>
 38c:	00000000 	nop
	{
	case CP0_STATUS:
		__asm__("mfc0 %0, $12"
 390:	40026000 	mfc0	v0,c0_status
 394:	00000000 	nop
 398:	afc20000 	sw	v0,0(s8)
				: "=r" (val)
				: /* no inputs */);
		break;
 39c:	1000000a 	b	3c8 <_mfc0+0x74>
 3a0:	00000000 	nop
	case CP0_CAUSE:
		__asm__("mfc0 %0, $13"
 3a4:	40026800 	mfc0	v0,c0_cause
 3a8:	00000000 	nop
 3ac:	afc20000 	sw	v0,0(s8)
				: "=r" (val)
				: /* no inputs */);
		break;
 3b0:	10000005 	b	3c8 <_mfc0+0x74>
 3b4:	00000000 	nop
	case CP0_EPC:
		__asm__("mfc0 %0, $14"
 3b8:	40027000 	mfc0	v0,c0_epc
 3bc:	00000000 	nop
 3c0:	afc20000 	sw	v0,0(s8)
				: "=r" (val)
				: /* no inputs */);
		break;
 3c4:	00000000 	nop
	}

	return val;
 3c8:	8fc20000 	lw	v0,0(s8)
}
 3cc:	03c0e825 	move	sp,s8
 3d0:	8fbe000c 	lw	s8,12(sp)
 3d4:	27bd0010 	addiu	sp,sp,16
 3d8:	03e00008 	jr	ra
 3dc:	00000000 	nop

000003e0 <_mtc0>:

void _mtc0(CP0_REG_t reg, uint32_t val)
{
 3e0:	27bdfff8 	addiu	sp,sp,-8
 3e4:	afbe0004 	sw	s8,4(sp)
 3e8:	03a0f025 	move	s8,sp
 3ec:	afc40008 	sw	a0,8(s8)
 3f0:	afc5000c 	sw	a1,12(s8)
	switch(reg)
 3f4:	8fc20008 	lw	v0,8(s8)
 3f8:	2403000d 	li	v1,13
 3fc:	1043000e 	beq	v0,v1,438 <_mtc0+0x58>
 400:	00000000 	nop
 404:	2403000e 	li	v1,14
 408:	10430010 	beq	v0,v1,44c <_mtc0+0x6c>
 40c:	00000000 	nop
 410:	2403000c 	li	v1,12
 414:	10430003 	beq	v0,v1,424 <_mtc0+0x44>
 418:	00000000 	nop
		__asm__("mtc0 %0, $14"
				: /* no outputs */
				: "r" (val));
		break;
	}
}
 41c:	1000000f 	b	45c <_mtc0+0x7c>
 420:	00000000 	nop
void _mtc0(CP0_REG_t reg, uint32_t val)
{
	switch(reg)
	{
	case CP0_STATUS:
		__asm__("mtc0 %0, $12"
 424:	8fc2000c 	lw	v0,12(s8)
 428:	00000000 	nop
 42c:	40826000 	mtc0	v0,c0_status
				: /* no outputs */
				: "r" (val));
		break;
 430:	1000000a 	b	45c <_mtc0+0x7c>
 434:	00000000 	nop
	case CP0_CAUSE:
		__asm__("mtc0 %0, $13"
 438:	8fc2000c 	lw	v0,12(s8)
 43c:	00000000 	nop
 440:	40826800 	mtc0	v0,c0_cause
				: /* no outputs */
				: "r" (val));
		break;
 444:	10000005 	b	45c <_mtc0+0x7c>
 448:	00000000 	nop
	case CP0_EPC:
		__asm__("mtc0 %0, $14"
 44c:	8fc2000c 	lw	v0,12(s8)
 450:	00000000 	nop
 454:	40827000 	mtc0	v0,c0_epc
	...
				: /* no outputs */
				: "r" (val));
		break;
	}
}
 460:	03c0e825 	move	sp,s8
 464:	8fbe0004 	lw	s8,4(sp)
 468:	27bd0008 	addiu	sp,sp,8
 46c:	03e00008 	jr	ra
 470:	00000000 	nop

00000474 <DMA_init>:
#include <config.h>
#include <cpu.h>


void DMA_init(Config_Channel_Info* Channel)
{
 474:	27bdffe0 	addiu	sp,sp,-32
 478:	afbf001c 	sw	ra,28(sp)
 47c:	afbe0018 	sw	s8,24(sp)
 480:	03a0f025 	move	s8,sp
 484:	afc40020 	sw	a0,32(s8)
    uint32_t controlRegVal = 0;
 488:	afc00010 	sw	zero,16(s8)

    controlRegVal = controlRegVal | ((Channel->ExEreignisEn << 4) | (Channel->IRFreigabe << 3)  |  (Channel->ByteTransfer << 2) | Channel->Betriebsmodus);
 48c:	8fc20020 	lw	v0,32(s8)
 490:	00000000 	nop
 494:	8c42001c 	lw	v0,28(v0)
 498:	00000000 	nop
 49c:	00021900 	sll	v1,v0,0x4
 4a0:	8fc20020 	lw	v0,32(s8)
 4a4:	00000000 	nop
 4a8:	8c420018 	lw	v0,24(v0)
 4ac:	00000000 	nop
 4b0:	000210c0 	sll	v0,v0,0x3
 4b4:	00621825 	or	v1,v1,v0
 4b8:	8fc20020 	lw	v0,32(s8)
 4bc:	00000000 	nop
 4c0:	8c420014 	lw	v0,20(v0)
 4c4:	00000000 	nop
 4c8:	00021080 	sll	v0,v0,0x2
 4cc:	00621825 	or	v1,v1,v0
 4d0:	8fc20020 	lw	v0,32(s8)
 4d4:	00000000 	nop
 4d8:	8c420010 	lw	v0,16(v0)
 4dc:	00000000 	nop
 4e0:	00621025 	or	v0,v1,v0
 4e4:	8fc30010 	lw	v1,16(s8)
 4e8:	00000000 	nop
 4ec:	00621025 	or	v0,v1,v0
 4f0:	afc20010 	sw	v0,16(s8)

    if(CHANNEL_0 == Channel->ChannelNumber)
 4f4:	8fc20020 	lw	v0,32(s8)
 4f8:	00000000 	nop
 4fc:	8c430000 	lw	v1,0(v0)
 500:	24020001 	li	v0,1
 504:	14620022 	bne	v1,v0,590 <DMA_init+0x11c>
 508:	00000000 	nop
    {
        //Source Address configuration
        out32(DMA_BASE + DMA_SAR0, Channel->SourceAddress);
 50c:	8fc20020 	lw	v0,32(s8)
 510:	00000000 	nop
 514:	8c420004 	lw	v0,4(v0)
 518:	00000000 	nop
 51c:	00402825 	move	a1,v0
 520:	3c040003 	lui	a0,0x3
 524:	0c000064 	jal	190 <out32>
 528:	00000000 	nop

        //Destination Address configuration
        out32(DMA_BASE + DMA_DESTR0, Channel->DestinationAddress);
 52c:	8fc20020 	lw	v0,32(s8)
 530:	00000000 	nop
 534:	8c420008 	lw	v0,8(v0)
 538:	00000000 	nop
 53c:	00402825 	move	a1,v0
 540:	3c020003 	lui	v0,0x3
 544:	34440004 	ori	a0,v0,0x4
 548:	0c000064 	jal	190 <out32>
 54c:	00000000 	nop

        //Number of transfers
        out32(DMA_BASE + DMA_TRAAR0, Channel->TransferNumber);
 550:	8fc20020 	lw	v0,32(s8)
 554:	00000000 	nop
 558:	8c42000c 	lw	v0,12(v0)
 55c:	00000000 	nop
 560:	00402825 	move	a1,v0
 564:	3c020003 	lui	v0,0x3
 568:	34440008 	ori	a0,v0,0x8
 56c:	0c000064 	jal	190 <out32>
 570:	00000000 	nop

        //Control Register
        out32(DMA_BASE + DMA_CR0, controlRegVal);
 574:	8fc50010 	lw	a1,16(s8)
 578:	3c020003 	lui	v0,0x3
 57c:	3444000c 	ori	a0,v0,0xc
 580:	0c000064 	jal	190 <out32>
 584:	00000000 	nop
 588:	10000077 	b	768 <DMA_init+0x2f4>
 58c:	00000000 	nop
    }
    else if(CHANNEL_1 == Channel->ChannelNumber)
 590:	8fc20020 	lw	v0,32(s8)
 594:	00000000 	nop
 598:	8c430000 	lw	v1,0(v0)
 59c:	24020002 	li	v0,2
 5a0:	14620023 	bne	v1,v0,630 <DMA_init+0x1bc>
 5a4:	00000000 	nop
    {
        //Source Address configuration
        out32(DMA_BASE + DMA_SAR1, Channel->SourceAddress);
 5a8:	8fc20020 	lw	v0,32(s8)
 5ac:	00000000 	nop
 5b0:	8c420004 	lw	v0,4(v0)
 5b4:	00000000 	nop
 5b8:	00402825 	move	a1,v0
 5bc:	3c020003 	lui	v0,0x3
 5c0:	34440010 	ori	a0,v0,0x10
 5c4:	0c000064 	jal	190 <out32>
 5c8:	00000000 	nop

        //Destination Address configuration
        out32(DMA_BASE + DMA_DESTR1, Channel->DestinationAddress);
 5cc:	8fc20020 	lw	v0,32(s8)
 5d0:	00000000 	nop
 5d4:	8c420008 	lw	v0,8(v0)
 5d8:	00000000 	nop
 5dc:	00402825 	move	a1,v0
 5e0:	3c020003 	lui	v0,0x3
 5e4:	34440014 	ori	a0,v0,0x14
 5e8:	0c000064 	jal	190 <out32>
 5ec:	00000000 	nop

        //Number of transfers
        out32(DMA_BASE + DMA_TRAAR1, Channel->TransferNumber);
 5f0:	8fc20020 	lw	v0,32(s8)
 5f4:	00000000 	nop
 5f8:	8c42000c 	lw	v0,12(v0)
 5fc:	00000000 	nop
 600:	00402825 	move	a1,v0
 604:	3c020003 	lui	v0,0x3
 608:	34440018 	ori	a0,v0,0x18
 60c:	0c000064 	jal	190 <out32>
 610:	00000000 	nop

        //Control Register
        out32(DMA_BASE + DMA_CR1, controlRegVal);
 614:	8fc50010 	lw	a1,16(s8)
 618:	3c020003 	lui	v0,0x3
 61c:	3444001c 	ori	a0,v0,0x1c
 620:	0c000064 	jal	190 <out32>
 624:	00000000 	nop
 628:	1000004f 	b	768 <DMA_init+0x2f4>
 62c:	00000000 	nop
    }
    else if(CHANNEL_2 == Channel->ChannelNumber)
 630:	8fc20020 	lw	v0,32(s8)
 634:	00000000 	nop
 638:	8c430000 	lw	v1,0(v0)
 63c:	24020004 	li	v0,4
 640:	14620023 	bne	v1,v0,6d0 <DMA_init+0x25c>
 644:	00000000 	nop
    {
        //Source Address configuration
        out32(DMA_BASE + DMA_SAR2, Channel->SourceAddress);
 648:	8fc20020 	lw	v0,32(s8)
 64c:	00000000 	nop
 650:	8c420004 	lw	v0,4(v0)
 654:	00000000 	nop
 658:	00402825 	move	a1,v0
 65c:	3c020003 	lui	v0,0x3
 660:	34440020 	ori	a0,v0,0x20
 664:	0c000064 	jal	190 <out32>
 668:	00000000 	nop

        //Destination Address configuration
        out32(DMA_BASE + DMA_DESTR2, Channel->DestinationAddress);
 66c:	8fc20020 	lw	v0,32(s8)
 670:	00000000 	nop
 674:	8c420008 	lw	v0,8(v0)
 678:	00000000 	nop
 67c:	00402825 	move	a1,v0
 680:	3c020003 	lui	v0,0x3
 684:	34440024 	ori	a0,v0,0x24
 688:	0c000064 	jal	190 <out32>
 68c:	00000000 	nop

        //Number of transfers
        out32(DMA_BASE + DMA_TRAAR2, Channel->TransferNumber);
 690:	8fc20020 	lw	v0,32(s8)
 694:	00000000 	nop
 698:	8c42000c 	lw	v0,12(v0)
 69c:	00000000 	nop
 6a0:	00402825 	move	a1,v0
 6a4:	3c020003 	lui	v0,0x3
 6a8:	34440028 	ori	a0,v0,0x28
 6ac:	0c000064 	jal	190 <out32>
 6b0:	00000000 	nop

        //Control Register
        out32(DMA_BASE + DMA_CR2, controlRegVal);
 6b4:	8fc50010 	lw	a1,16(s8)
 6b8:	3c020003 	lui	v0,0x3
 6bc:	3444002c 	ori	a0,v0,0x2c
 6c0:	0c000064 	jal	190 <out32>
 6c4:	00000000 	nop
 6c8:	10000027 	b	768 <DMA_init+0x2f4>
 6cc:	00000000 	nop
    }
    else if(CHANNEL_3 == Channel->ChannelNumber)
 6d0:	8fc20020 	lw	v0,32(s8)
 6d4:	00000000 	nop
 6d8:	8c430000 	lw	v1,0(v0)
 6dc:	24020008 	li	v0,8
 6e0:	14620021 	bne	v1,v0,768 <DMA_init+0x2f4>
 6e4:	00000000 	nop
    {
        //Source Address configuration
        out32(DMA_BASE + DMA_SAR3, Channel->SourceAddress);
 6e8:	8fc20020 	lw	v0,32(s8)
 6ec:	00000000 	nop
 6f0:	8c420004 	lw	v0,4(v0)
 6f4:	00000000 	nop
 6f8:	00402825 	move	a1,v0
 6fc:	3c020003 	lui	v0,0x3
 700:	34440030 	ori	a0,v0,0x30
 704:	0c000064 	jal	190 <out32>
 708:	00000000 	nop

        //Destination Address configuration
        out32(DMA_BASE + DMA_DESTR3, Channel->DestinationAddress);
 70c:	8fc20020 	lw	v0,32(s8)
 710:	00000000 	nop
 714:	8c420008 	lw	v0,8(v0)
 718:	00000000 	nop
 71c:	00402825 	move	a1,v0
 720:	3c020003 	lui	v0,0x3
 724:	34440034 	ori	a0,v0,0x34
 728:	0c000064 	jal	190 <out32>
 72c:	00000000 	nop

        //Number of transfers
        out32(DMA_BASE + DMA_TRAAR3, Channel->TransferNumber);
 730:	8fc20020 	lw	v0,32(s8)
 734:	00000000 	nop
 738:	8c42000c 	lw	v0,12(v0)
 73c:	00000000 	nop
 740:	00402825 	move	a1,v0
 744:	3c020003 	lui	v0,0x3
 748:	34440038 	ori	a0,v0,0x38
 74c:	0c000064 	jal	190 <out32>
 750:	00000000 	nop

        //Control Register
        out32(DMA_BASE + DMA_CR3, controlRegVal);
 754:	8fc50010 	lw	a1,16(s8)
 758:	3c020003 	lui	v0,0x3
 75c:	3444003c 	ori	a0,v0,0x3c
 760:	0c000064 	jal	190 <out32>
 764:	00000000 	nop
    }

    	// enable interrupt for DMA
	    cpu_enable_interrupt(DMA_INTR);
 768:	24040400 	li	a0,1024
 76c:	0c0000a3 	jal	28c <cpu_enable_interrupt>
 770:	00000000 	nop
}
 774:	00000000 	nop
 778:	03c0e825 	move	sp,s8
 77c:	8fbf001c 	lw	ra,28(sp)
 780:	8fbe0018 	lw	s8,24(sp)
 784:	27bd0020 	addiu	sp,sp,32
 788:	03e00008 	jr	ra
 78c:	00000000 	nop

00000790 <ChannelEnable>:


void ChannelEnable(Config_Channel_Info* Channel)
{
 790:	27bdffe8 	addiu	sp,sp,-24
 794:	afbf0014 	sw	ra,20(sp)
 798:	afbe0010 	sw	s8,16(sp)
 79c:	03a0f025 	move	s8,sp
 7a0:	afc40018 	sw	a0,24(s8)
    if(CHANNEL_0 == Channel->ChannelNumber)
 7a4:	8fc20018 	lw	v0,24(s8)
 7a8:	00000000 	nop
 7ac:	8c430000 	lw	v1,0(v0)
 7b0:	24020001 	li	v0,1
 7b4:	1462000d 	bne	v1,v0,7ec <ChannelEnable+0x5c>
 7b8:	00000000 	nop
    {
        out32(DMA_BASE + DMA_CR0, Channel->ControlRegVal | CHANNEL_EN);
 7bc:	8fc20018 	lw	v0,24(s8)
 7c0:	00000000 	nop
 7c4:	8c420020 	lw	v0,32(v0)
 7c8:	00000000 	nop
 7cc:	34420100 	ori	v0,v0,0x100
 7d0:	00402825 	move	a1,v0
 7d4:	3c020003 	lui	v0,0x3
 7d8:	3444000c 	ori	a0,v0,0xc
 7dc:	0c000064 	jal	190 <out32>
 7e0:	00000000 	nop
    }
    else if (CHANNEL_3 == Channel->ChannelNumber)
    {
        out32(DMA_BASE + DMA_CR3, Channel->ControlRegVal | CHANNEL_EN);
    }
}
 7e4:	10000035 	b	8bc <ChannelEnable+0x12c>
 7e8:	00000000 	nop
{
    if(CHANNEL_0 == Channel->ChannelNumber)
    {
        out32(DMA_BASE + DMA_CR0, Channel->ControlRegVal | CHANNEL_EN);
    }
    else if (CHANNEL_1 == Channel->ChannelNumber)
 7ec:	8fc20018 	lw	v0,24(s8)
 7f0:	00000000 	nop
 7f4:	8c430000 	lw	v1,0(v0)
 7f8:	24020002 	li	v0,2
 7fc:	1462000d 	bne	v1,v0,834 <ChannelEnable+0xa4>
 800:	00000000 	nop
    {
        out32(DMA_BASE + DMA_CR1, Channel->ControlRegVal | CHANNEL_EN);
 804:	8fc20018 	lw	v0,24(s8)
 808:	00000000 	nop
 80c:	8c420020 	lw	v0,32(v0)
 810:	00000000 	nop
 814:	34420100 	ori	v0,v0,0x100
 818:	00402825 	move	a1,v0
 81c:	3c020003 	lui	v0,0x3
 820:	3444001c 	ori	a0,v0,0x1c
 824:	0c000064 	jal	190 <out32>
 828:	00000000 	nop
    }
    else if (CHANNEL_3 == Channel->ChannelNumber)
    {
        out32(DMA_BASE + DMA_CR3, Channel->ControlRegVal | CHANNEL_EN);
    }
}
 82c:	10000023 	b	8bc <ChannelEnable+0x12c>
 830:	00000000 	nop
    }
    else if (CHANNEL_1 == Channel->ChannelNumber)
    {
        out32(DMA_BASE + DMA_CR1, Channel->ControlRegVal | CHANNEL_EN);
    }
    else if (CHANNEL_2 == Channel->ChannelNumber)
 834:	8fc20018 	lw	v0,24(s8)
 838:	00000000 	nop
 83c:	8c430000 	lw	v1,0(v0)
 840:	24020004 	li	v0,4
 844:	1462000d 	bne	v1,v0,87c <ChannelEnable+0xec>
 848:	00000000 	nop
    {
        out32(DMA_BASE + DMA_CR2, Channel->ControlRegVal | CHANNEL_EN);
 84c:	8fc20018 	lw	v0,24(s8)
 850:	00000000 	nop
 854:	8c420020 	lw	v0,32(v0)
 858:	00000000 	nop
 85c:	34420100 	ori	v0,v0,0x100
 860:	00402825 	move	a1,v0
 864:	3c020003 	lui	v0,0x3
 868:	3444002c 	ori	a0,v0,0x2c
 86c:	0c000064 	jal	190 <out32>
 870:	00000000 	nop
    }
    else if (CHANNEL_3 == Channel->ChannelNumber)
    {
        out32(DMA_BASE + DMA_CR3, Channel->ControlRegVal | CHANNEL_EN);
    }
}
 874:	10000011 	b	8bc <ChannelEnable+0x12c>
 878:	00000000 	nop
    }
    else if (CHANNEL_2 == Channel->ChannelNumber)
    {
        out32(DMA_BASE + DMA_CR2, Channel->ControlRegVal | CHANNEL_EN);
    }
    else if (CHANNEL_3 == Channel->ChannelNumber)
 87c:	8fc20018 	lw	v0,24(s8)
 880:	00000000 	nop
 884:	8c430000 	lw	v1,0(v0)
 888:	24020008 	li	v0,8
 88c:	1462000b 	bne	v1,v0,8bc <ChannelEnable+0x12c>
 890:	00000000 	nop
    {
        out32(DMA_BASE + DMA_CR3, Channel->ControlRegVal | CHANNEL_EN);
 894:	8fc20018 	lw	v0,24(s8)
 898:	00000000 	nop
 89c:	8c420020 	lw	v0,32(v0)
 8a0:	00000000 	nop
 8a4:	34420100 	ori	v0,v0,0x100
 8a8:	00402825 	move	a1,v0
 8ac:	3c020003 	lui	v0,0x3
 8b0:	3444003c 	ori	a0,v0,0x3c
 8b4:	0c000064 	jal	190 <out32>
 8b8:	00000000 	nop
    }
}
 8bc:	00000000 	nop
 8c0:	03c0e825 	move	sp,s8
 8c4:	8fbf0014 	lw	ra,20(sp)
 8c8:	8fbe0010 	lw	s8,16(sp)
 8cc:	27bd0018 	addiu	sp,sp,24
 8d0:	03e00008 	jr	ra
 8d4:	00000000 	nop

000008d8 <InterruptAck>:

void InterruptAck(Config_Channel_Info* Channel)
{
 8d8:	27bdffe8 	addiu	sp,sp,-24
 8dc:	afbf0014 	sw	ra,20(sp)
 8e0:	afbe0010 	sw	s8,16(sp)
 8e4:	03a0f025 	move	s8,sp
 8e8:	afc40018 	sw	a0,24(s8)
    if(CHANNEL_0 == Channel->ChannelNumber)
 8ec:	8fc20018 	lw	v0,24(s8)
 8f0:	00000000 	nop
 8f4:	8c430000 	lw	v1,0(v0)
 8f8:	24020001 	li	v0,1
 8fc:	1462000d 	bne	v1,v0,934 <InterruptAck+0x5c>
 900:	00000000 	nop
    {
        out32(DMA_BASE + DMA_CR0, Channel->ControlRegVal | CHANNEL_IR_ACK);
 904:	8fc20018 	lw	v0,24(s8)
 908:	00000000 	nop
 90c:	8c420020 	lw	v0,32(v0)
 910:	00000000 	nop
 914:	34420200 	ori	v0,v0,0x200
 918:	00402825 	move	a1,v0
 91c:	3c020003 	lui	v0,0x3
 920:	3444000c 	ori	a0,v0,0xc
 924:	0c000064 	jal	190 <out32>
 928:	00000000 	nop
    }
    else if (CHANNEL_3 == Channel->ChannelNumber)
    {
        out32(DMA_BASE + DMA_CR3, Channel->ControlRegVal | CHANNEL_IR_ACK);
    }
}
 92c:	10000035 	b	a04 <InterruptAck+0x12c>
 930:	00000000 	nop
{
    if(CHANNEL_0 == Channel->ChannelNumber)
    {
        out32(DMA_BASE + DMA_CR0, Channel->ControlRegVal | CHANNEL_IR_ACK);
    }
    else if (CHANNEL_1 == Channel->ChannelNumber)
 934:	8fc20018 	lw	v0,24(s8)
 938:	00000000 	nop
 93c:	8c430000 	lw	v1,0(v0)
 940:	24020002 	li	v0,2
 944:	1462000d 	bne	v1,v0,97c <InterruptAck+0xa4>
 948:	00000000 	nop
    {
        out32(DMA_BASE + DMA_CR1, Channel->ControlRegVal | CHANNEL_IR_ACK);
 94c:	8fc20018 	lw	v0,24(s8)
 950:	00000000 	nop
 954:	8c420020 	lw	v0,32(v0)
 958:	00000000 	nop
 95c:	34420200 	ori	v0,v0,0x200
 960:	00402825 	move	a1,v0
 964:	3c020003 	lui	v0,0x3
 968:	3444001c 	ori	a0,v0,0x1c
 96c:	0c000064 	jal	190 <out32>
 970:	00000000 	nop
    }
    else if (CHANNEL_3 == Channel->ChannelNumber)
    {
        out32(DMA_BASE + DMA_CR3, Channel->ControlRegVal | CHANNEL_IR_ACK);
    }
}
 974:	10000023 	b	a04 <InterruptAck+0x12c>
 978:	00000000 	nop
    }
    else if (CHANNEL_1 == Channel->ChannelNumber)
    {
        out32(DMA_BASE + DMA_CR1, Channel->ControlRegVal | CHANNEL_IR_ACK);
    }
    else if (CHANNEL_2 == Channel->ChannelNumber)
 97c:	8fc20018 	lw	v0,24(s8)
 980:	00000000 	nop
 984:	8c430000 	lw	v1,0(v0)
 988:	24020004 	li	v0,4
 98c:	1462000d 	bne	v1,v0,9c4 <InterruptAck+0xec>
 990:	00000000 	nop
    {
        out32(DMA_BASE + DMA_CR2, Channel->ControlRegVal | CHANNEL_IR_ACK);
 994:	8fc20018 	lw	v0,24(s8)
 998:	00000000 	nop
 99c:	8c420020 	lw	v0,32(v0)
 9a0:	00000000 	nop
 9a4:	34420200 	ori	v0,v0,0x200
 9a8:	00402825 	move	a1,v0
 9ac:	3c020003 	lui	v0,0x3
 9b0:	3444002c 	ori	a0,v0,0x2c
 9b4:	0c000064 	jal	190 <out32>
 9b8:	00000000 	nop
    }
    else if (CHANNEL_3 == Channel->ChannelNumber)
    {
        out32(DMA_BASE + DMA_CR3, Channel->ControlRegVal | CHANNEL_IR_ACK);
    }
}
 9bc:	10000011 	b	a04 <InterruptAck+0x12c>
 9c0:	00000000 	nop
    }
    else if (CHANNEL_2 == Channel->ChannelNumber)
    {
        out32(DMA_BASE + DMA_CR2, Channel->ControlRegVal | CHANNEL_IR_ACK);
    }
    else if (CHANNEL_3 == Channel->ChannelNumber)
 9c4:	8fc20018 	lw	v0,24(s8)
 9c8:	00000000 	nop
 9cc:	8c430000 	lw	v1,0(v0)
 9d0:	24020008 	li	v0,8
 9d4:	1462000b 	bne	v1,v0,a04 <InterruptAck+0x12c>
 9d8:	00000000 	nop
    {
        out32(DMA_BASE + DMA_CR3, Channel->ControlRegVal | CHANNEL_IR_ACK);
 9dc:	8fc20018 	lw	v0,24(s8)
 9e0:	00000000 	nop
 9e4:	8c420020 	lw	v0,32(v0)
 9e8:	00000000 	nop
 9ec:	34420200 	ori	v0,v0,0x200
 9f0:	00402825 	move	a1,v0
 9f4:	3c020003 	lui	v0,0x3
 9f8:	3444003c 	ori	a0,v0,0x3c
 9fc:	0c000064 	jal	190 <out32>
 a00:	00000000 	nop
    }
}
 a04:	00000000 	nop
 a08:	03c0e825 	move	sp,s8
 a0c:	8fbf0014 	lw	ra,20(sp)
 a10:	8fbe0010 	lw	s8,16(sp)
 a14:	27bd0018 	addiu	sp,sp,24
 a18:	03e00008 	jr	ra
 a1c:	00000000 	nop

00000a20 <outbyte>:
void __attribute__ ((weak)) outbyte(int c)
{
 a20:	27bdfff8 	addiu	sp,sp,-8
 a24:	afbe0004 	sw	s8,4(sp)
 a28:	03a0f025 	move	s8,sp
 a2c:	afc40008 	sw	a0,8(s8)
	return;
 a30:	00000000 	nop
}
 a34:	03c0e825 	move	sp,s8
 a38:	8fbe0004 	lw	s8,4(sp)
 a3c:	27bd0008 	addiu	sp,sp,8
 a40:	03e00008 	jr	ra
 a44:	00000000 	nop

00000a48 <inbyte>:

int __attribute__ ((weak)) inbyte()
{
 a48:	27bdfff8 	addiu	sp,sp,-8
 a4c:	afbe0004 	sw	s8,4(sp)
 a50:	03a0f025 	move	s8,sp
	return -1;
 a54:	2402ffff 	li	v0,-1
}
 a58:	03c0e825 	move	sp,s8
 a5c:	8fbe0004 	lw	s8,4(sp)
 a60:	27bd0008 	addiu	sp,sp,8
 a64:	03e00008 	jr	ra
 a68:	00000000 	nop

00000a6c <IP2_Handler>:
#define TEXT_MAX_LENGTH  1024
volatile uint32_t configChannel_0;
Config_Channel_Info* volatile Channel_0_p;

void DMA_Handler()
{
 a6c:	27bdffe0 	addiu	sp,sp,-32
 a70:	afbf001c 	sw	ra,28(sp)
 a74:	afbe0018 	sw	s8,24(sp)
 a78:	03a0f025 	move	s8,sp
	uint32_t status = in32(DMA_BASE + DMA_SR);
 a7c:	3c020003 	lui	v0,0x3
 a80:	34440040 	ori	a0,v0,0x40
 a84:	0c000073 	jal	1cc <in32>
 a88:	00000000 	nop
 a8c:	afc20010 	sw	v0,16(s8)

	if(status & DMA_CHA0_IRQ)
 a90:	8fc30010 	lw	v1,16(s8)
 a94:	3c020001 	lui	v0,0x1
 a98:	00621024 	and	v0,v1,v0
 a9c:	10400006 	beqz	v0,ab8 <IP2_Handler+0x4c>
 aa0:	00000000 	nop
	{
		//
		//Interrupt quittieren
		//
		InterruptAck(Channel_0_p);
 aa4:	8f820000 	lw	v0,0(gp)
 aa8:	00000000 	nop
 aac:	00402025 	move	a0,v0
 ab0:	0c000236 	jal	8d8 <InterruptAck>
 ab4:	00000000 	nop
	}
}
 ab8:	00000000 	nop
 abc:	03c0e825 	move	sp,s8
 ac0:	8fbf001c 	lw	ra,28(sp)
 ac4:	8fbe0018 	lw	s8,24(sp)
 ac8:	27bd0020 	addiu	sp,sp,32
 acc:	03e00008 	jr	ra
 ad0:	00000000 	nop

00000ad4 <main>:

int main()
{
 ad4:	27bdf7b0 	addiu	sp,sp,-2128
 ad8:	afbf084c 	sw	ra,2124(sp)
 adc:	afbe0848 	sw	s8,2120(sp)
 ae0:	03a0f025 	move	s8,sp
	const char Gedicht[TEXT_MAX_LENGTH] =
 ae4:	3c020000 	lui	v0,0x0
 ae8:	27c30020 	addiu	v1,s8,32
 aec:	24420eb0 	addiu	v0,v0,3760
 af0:	24040174 	li	a0,372
 af4:	00803025 	move	a2,a0
 af8:	00402825 	move	a1,v0
 afc:	00602025 	move	a0,v1
 b00:	0c000345 	jal	d14 <memcpy>
 b04:	00000000 	nop
 b08:	27c20194 	addiu	v0,s8,404
 b0c:	2403028c 	li	v1,652
 b10:	00603025 	move	a2,v1
 b14:	00002825 	move	a1,zero
 b18:	00402025 	move	a0,v0
 b1c:	0c00036a 	jal	da8 <memset>
 b20:	00000000 	nop
	    "Und ziehe schon an die zehen Jahr\r\n"
	    "Herauf, herab und quer und krumm\r\n"
	    "Meine Schueler an der Nase herum -\r\n"
	    "Und sehe, dass wir nichts wissen koennen!\r\n";

	uint32_t i = 0;
 b24:	afc00010 	sw	zero,16(s8)
	//
	//L�nge des Gedichtes bestimmen
	//
	while(Gedicht[i] != '\0')
 b28:	10000005 	b	b40 <main+0x6c>
 b2c:	00000000 	nop
		i++;
 b30:	8fc20010 	lw	v0,16(s8)
 b34:	00000000 	nop
 b38:	24420001 	addiu	v0,v0,1
 b3c:	afc20010 	sw	v0,16(s8)

	uint32_t i = 0;
	//
	//L�nge des Gedichtes bestimmen
	//
	while(Gedicht[i] != '\0')
 b40:	8fc20010 	lw	v0,16(s8)
 b44:	27c30010 	addiu	v1,s8,16
 b48:	00621021 	addu	v0,v1,v0
 b4c:	90420010 	lbu	v0,16(v0)
 b50:	00000000 	nop
 b54:	1440fff6 	bnez	v0,b30 <main+0x5c>
 b58:	00000000 	nop
		i++;

	const uint32_t TextLength = ++i;
 b5c:	8fc20010 	lw	v0,16(s8)
 b60:	00000000 	nop
 b64:	24420001 	addiu	v0,v0,1
 b68:	afc20010 	sw	v0,16(s8)
 b6c:	8fc20010 	lw	v0,16(s8)
 b70:	00000000 	nop
 b74:	afc2001c 	sw	v0,28(s8)
	char NeuesGedicht[TEXT_MAX_LENGTH];
	bool_t Tra_Fertig = FALSE;
 b78:	afc00014 	sw	zero,20(s8)

	//
	//Struct mit der Einstellung des Kanals 0
	//
	Config_Channel_Info Channel_0_Config = {CHANNEL_0,(uint32_t)(Gedicht+10),(uint32_t)(NeuesGedicht+6),TextLength,SPEI_SPEI,FALSE,TRUE,FALSE};
 b7c:	afc00820 	sw	zero,2080(s8)
 b80:	afc00824 	sw	zero,2084(s8)
 b84:	afc00828 	sw	zero,2088(s8)
 b88:	afc0082c 	sw	zero,2092(s8)
 b8c:	afc00830 	sw	zero,2096(s8)
 b90:	afc00834 	sw	zero,2100(s8)
 b94:	afc00838 	sw	zero,2104(s8)
 b98:	afc0083c 	sw	zero,2108(s8)
 b9c:	afc00840 	sw	zero,2112(s8)
 ba0:	24020001 	li	v0,1
 ba4:	afc20820 	sw	v0,2080(s8)
 ba8:	27c20020 	addiu	v0,s8,32
 bac:	2442000a 	addiu	v0,v0,10
 bb0:	afc20824 	sw	v0,2084(s8)
 bb4:	27c20420 	addiu	v0,s8,1056
 bb8:	24420006 	addiu	v0,v0,6
 bbc:	afc20828 	sw	v0,2088(s8)
 bc0:	8fc2001c 	lw	v0,28(s8)
 bc4:	00000000 	nop
 bc8:	afc2082c 	sw	v0,2092(s8)
 bcc:	24020001 	li	v0,1
 bd0:	afc20838 	sw	v0,2104(s8)

	//
	//Channel Initialisierung
	//
	DMA_init(&Channel_0_Config);
 bd4:	27c20820 	addiu	v0,s8,2080
 bd8:	00402025 	move	a0,v0
 bdc:	0c00011d 	jal	474 <DMA_init>
 be0:	00000000 	nop

	//
	//Wert vom Kontroll-Register speichern
	//
	Channel_0_Config.ControlRegVal = in32(DMA_BASE + DMA_CR0);
 be4:	3c020003 	lui	v0,0x3
 be8:	3444000c 	ori	a0,v0,0xc
 bec:	0c000073 	jal	1cc <in32>
 bf0:	00000000 	nop
 bf4:	afc20840 	sw	v0,2112(s8)

	//
	//Zuweisung an die globale Variable
	//
	Channel_0_p = &Channel_0_Config;
 bf8:	27c20820 	addiu	v0,s8,2080
 bfc:	af820000 	sw	v0,0(gp)

	//
	//Kanal starten
	//
	ChannelEnable(&Channel_0_Config);
 c00:	27c20820 	addiu	v0,s8,2080
 c04:	00402025 	move	a0,v0
 c08:	0c0001e4 	jal	790 <ChannelEnable>
 c0c:	00000000 	nop

		while(1)
		{
			if((in32(DMA_BASE + DMA_SR) & CHANNEL_0) == 0 && Tra_Fertig == FALSE)
 c10:	3c020003 	lui	v0,0x3
 c14:	34440040 	ori	a0,v0,0x40
 c18:	0c000073 	jal	1cc <in32>
 c1c:	00000000 	nop
 c20:	30420001 	andi	v0,v0,0x1
 c24:	1440fffa 	bnez	v0,c10 <main+0x13c>
 c28:	00000000 	nop
 c2c:	8fc20014 	lw	v0,20(s8)
 c30:	00000000 	nop
 c34:	1440fff6 	bnez	v0,c10 <main+0x13c>
 c38:	00000000 	nop
			{
				for(int i = 0; i <= TextLength; i++)
 c3c:	afc00018 	sw	zero,24(s8)
 c40:	10000027 	b	ce0 <main+0x20c>
 c44:	00000000 	nop
				{
					if(NeuesGedicht[i] == '\0')
 c48:	8fc20018 	lw	v0,24(s8)
 c4c:	27c30010 	addiu	v1,s8,16
 c50:	00621021 	addu	v0,v1,v0
 c54:	90420410 	lbu	v0,1040(v0)
 c58:	00000000 	nop
 c5c:	10400028 	beqz	v0,d00 <main+0x22c>
 c60:	00000000 	nop
						break;

					//
					//Ist der Transfer erfolgreich, soll die folgende Anweisung immer falsch sein
					//
					else if(Gedicht[i + 10] != NeuesGedicht[i + 6])
 c64:	8fc20018 	lw	v0,24(s8)
 c68:	00000000 	nop
 c6c:	2442000a 	addiu	v0,v0,10
 c70:	27c30010 	addiu	v1,s8,16
 c74:	00621021 	addu	v0,v1,v0
 c78:	90430010 	lbu	v1,16(v0)
 c7c:	8fc20018 	lw	v0,24(s8)
 c80:	00000000 	nop
 c84:	24420006 	addiu	v0,v0,6
 c88:	27c40010 	addiu	a0,s8,16
 c8c:	00821021 	addu	v0,a0,v0
 c90:	90420410 	lbu	v0,1040(v0)
 c94:	00000000 	nop
 c98:	1062000d 	beq	v1,v0,cd0 <main+0x1fc>
 c9c:	00000000 	nop
						out32(DMA_BASE + DMA_CR0, in32(DMA_BASE +  DMA_CR0) & ~(1<<3));
 ca0:	3c020003 	lui	v0,0x3
 ca4:	3444000c 	ori	a0,v0,0xc
 ca8:	0c000073 	jal	1cc <in32>
 cac:	00000000 	nop
 cb0:	00401825 	move	v1,v0
 cb4:	2402fff7 	li	v0,-9
 cb8:	00621024 	and	v0,v1,v0
 cbc:	00402825 	move	a1,v0
 cc0:	3c020003 	lui	v0,0x3
 cc4:	3444000c 	ori	a0,v0,0xc
 cc8:	0c000064 	jal	190 <out32>
 ccc:	00000000 	nop

		while(1)
		{
			if((in32(DMA_BASE + DMA_SR) & CHANNEL_0) == 0 && Tra_Fertig == FALSE)
			{
				for(int i = 0; i <= TextLength; i++)
 cd0:	8fc20018 	lw	v0,24(s8)
 cd4:	00000000 	nop
 cd8:	24420001 	addiu	v0,v0,1
 cdc:	afc20018 	sw	v0,24(s8)
 ce0:	8fc30018 	lw	v1,24(s8)
 ce4:	8fc2001c 	lw	v0,28(s8)
 ce8:	00000000 	nop
 cec:	0043102b 	sltu	v0,v0,v1
 cf0:	1040ffd5 	beqz	v0,c48 <main+0x174>
 cf4:	00000000 	nop
 cf8:	10000002 	b	d04 <main+0x230>
 cfc:	00000000 	nop
				{
					if(NeuesGedicht[i] == '\0')
						break;
 d00:	00000000 	nop
					//
					else if(Gedicht[i + 10] != NeuesGedicht[i + 6])
						out32(DMA_BASE + DMA_CR0, in32(DMA_BASE +  DMA_CR0) & ~(1<<3));
				}

				Tra_Fertig = TRUE;
 d04:	24020001 	li	v0,1
 d08:	afc20014 	sw	v0,20(s8)
			}
		}
 d0c:	1000ffc0 	b	c10 <main+0x13c>
 d10:	00000000 	nop

00000d14 <memcpy>:

#include <string.h>
#include <stddef.h> // Include for size_t definition

void *memcpy(void *dest, const void *src, size_t count)
{
 d14:	27bdfff0 	addiu	sp,sp,-16
 d18:	afbe000c 	sw	s8,12(sp)
 d1c:	03a0f025 	move	s8,sp
 d20:	afc40010 	sw	a0,16(s8)
 d24:	afc50014 	sw	a1,20(s8)
 d28:	afc60018 	sw	a2,24(s8)
	char *dst8 = (char *)dest;
 d2c:	8fc20010 	lw	v0,16(s8)
 d30:	00000000 	nop
 d34:	afc20000 	sw	v0,0(s8)
	char *src8 = (char *)src;
 d38:	8fc20014 	lw	v0,20(s8)
 d3c:	00000000 	nop
 d40:	afc20004 	sw	v0,4(s8)

	while (count--) {
 d44:	1000000c 	b	d78 <memcpy+0x64>
 d48:	00000000 	nop
		*dst8++ = *src8++;
 d4c:	8fc20000 	lw	v0,0(s8)
 d50:	00000000 	nop
 d54:	24430001 	addiu	v1,v0,1
 d58:	afc30000 	sw	v1,0(s8)
 d5c:	8fc30004 	lw	v1,4(s8)
 d60:	00000000 	nop
 d64:	24640001 	addiu	a0,v1,1
 d68:	afc40004 	sw	a0,4(s8)
 d6c:	90630000 	lbu	v1,0(v1)
 d70:	00000000 	nop
 d74:	a0430000 	sb	v1,0(v0)
void *memcpy(void *dest, const void *src, size_t count)
{
	char *dst8 = (char *)dest;
	char *src8 = (char *)src;

	while (count--) {
 d78:	8fc20018 	lw	v0,24(s8)
 d7c:	00000000 	nop
 d80:	2443ffff 	addiu	v1,v0,-1
 d84:	afc30018 	sw	v1,24(s8)
 d88:	1440fff0 	bnez	v0,d4c <memcpy+0x38>
 d8c:	00000000 	nop
		*dst8++ = *src8++;
	}
	return dest;
 d90:	8fc20010 	lw	v0,16(s8)
}
 d94:	03c0e825 	move	sp,s8
 d98:	8fbe000c 	lw	s8,12(sp)
 d9c:	27bd0010 	addiu	sp,sp,16
 da0:	03e00008 	jr	ra
 da4:	00000000 	nop

00000da8 <memset>:
#include <string.h>
#include <stddef.h> // Include for size_t definition

void *memset(void *dest, int c, size_t count)
{
 da8:	27bdfff0 	addiu	sp,sp,-16
 dac:	afbe000c 	sw	s8,12(sp)
 db0:	03a0f025 	move	s8,sp
 db4:	afc40010 	sw	a0,16(s8)
 db8:	afc50014 	sw	a1,20(s8)
 dbc:	afc60018 	sw	a2,24(s8)
	char *dst8 = (char *)dest;
 dc0:	8fc20010 	lw	v0,16(s8)
 dc4:	00000000 	nop
 dc8:	afc20000 	sw	v0,0(s8)

	while (count--) {
 dcc:	10000009 	b	df4 <memset+0x4c>
 dd0:	00000000 	nop
		*dst8++ = c;
 dd4:	8fc20000 	lw	v0,0(s8)
 dd8:	00000000 	nop
 ddc:	24430001 	addiu	v1,v0,1
 de0:	afc30000 	sw	v1,0(s8)
 de4:	8fc30014 	lw	v1,20(s8)
 de8:	00000000 	nop
 dec:	306300ff 	andi	v1,v1,0xff
 df0:	a0430000 	sb	v1,0(v0)

void *memset(void *dest, int c, size_t count)
{
	char *dst8 = (char *)dest;

	while (count--) {
 df4:	8fc20018 	lw	v0,24(s8)
 df8:	00000000 	nop
 dfc:	2443ffff 	addiu	v1,v0,-1
 e00:	afc30018 	sw	v1,24(s8)
 e04:	1440fff3 	bnez	v0,dd4 <memset+0x2c>
 e08:	00000000 	nop
		*dst8++ = c;
	}
	return dest;
 e0c:	8fc20010 	lw	v0,16(s8)
}
 e10:	03c0e825 	move	sp,s8
 e14:	8fbe000c 	lw	s8,12(sp)
 e18:	27bd0010 	addiu	sp,sp,16
 e1c:	03e00008 	jr	ra
 e20:	00000000 	nop

00000e24 <_premain>:
extern char _bss_end;

int main();

void _premain()
{
 e24:	27bdffe8 	addiu	sp,sp,-24
 e28:	afbf0014 	sw	ra,20(sp)
 e2c:	afbe0010 	sw	s8,16(sp)
 e30:	03a0f025 	move	s8,sp
	/* move initialized data from ROM to RAM */
	if ((&_data_start) != (&_data_start_rom)) {
 e34:	27830000 	addiu	v1,gp,0
 e38:	2782d2b0 	addiu	v0,gp,-11600
 e3c:	10620009 	beq	v1,v0,e64 <_premain+0x40>
 e40:	00000000 	nop
		memcpy(&_data_start, &_data_start_rom, &_data_end - &_data_start);
 e44:	27830000 	addiu	v1,gp,0
 e48:	27820000 	addiu	v0,gp,0
 e4c:	00621023 	subu	v0,v1,v0
 e50:	00403025 	move	a2,v0
 e54:	2785d2b0 	addiu	a1,gp,-11600
 e58:	27840000 	addiu	a0,gp,0
 e5c:	0c000345 	jal	d14 <memcpy>
 e60:	00000000 	nop
	}

	memset(&_bss_start, 0, &_bss_end - &_bss_start);
 e64:	27830000 	addiu	v1,gp,0
 e68:	27820000 	addiu	v0,gp,0
 e6c:	00621023 	subu	v0,v1,v0
 e70:	00403025 	move	a2,v0
 e74:	00002825 	move	a1,zero
 e78:	27840000 	addiu	a0,gp,0
 e7c:	0c00036a 	jal	da8 <memset>
 e80:	00000000 	nop

	main();
 e84:	0c0002b5 	jal	ad4 <main>
 e88:	00000000 	nop
	while(1);
 e8c:	1000ffff 	b	e8c <_premain+0x68>
 e90:	00000000 	nop
